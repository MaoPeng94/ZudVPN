'use strict';

import SSHClient from './../../ssh/client';
import AsyncStorage from '@react-native-community/async-storage';
import CloudInitUserData from './cloudinit_userdata';
import { sleep } from './../../helper';
import Keygen from './../../ssh/keygen';

const DropletBaseName = 'zudvpn';
const DropletImage = 'coreos-stable';
const DropletSize = 's-1vcpu-1gb';
const AutogeneratedSSHKey = 'zudvpn';

const Deploy = ({ client, token, region, setLog }) => {
    const name = `${DropletBaseName}-${region}`;

    const run = async () => {
        console.log('Reading SSH keys from provider.');
        setLog('Reading SSH keys from provider.');
        let sshKeys = await client.getAccountSSHKeys();
        let sshKeyId = null;
        let sshKeyPair = null;

        for (let i = 0, l = sshKeys.length; i < l; i++) {
            sshKeyId = sshKeys[i];
            sshKeyPair = await AsyncStorage.getItem('SSH_KEY_PAIR' + sshKeyId);
            if (sshKeyPair) {
                console.log('Found SSH keypair in storage, parsing.');
                setLog('Found SSH keypair in storage, parsing.');
                sshKeyPair = JSON.parse(sshKeyPair);
                break;
            }
        }

        if (!sshKeyPair) {
            console.log('SSH keypair not available, generating.');
            setLog('SSH keypair not available, generating.');
            sshKeyPair = await Keygen.generateKeyPair();

            console.log('Creating SSH key with generated keypair.');
            setLog('Creating SSH key with generated keypair.');
            sshKeyId = await client.createSSHKey(AutogeneratedSSHKey, sshKeyPair.authorizedKey);
            sshKeys.push(sshKeyId);

            console.log('Saving SSH keypair by SSH key id to storage.');
            setLog('Saving SSH keypair by SSH key id to storage.');
            AsyncStorage.setItem('SSH_KEY_PAIR' + sshKeyId, JSON.stringify(sshKeyPair));
        }

        console.log('SSH Keypair:', sshKeyPair);
        setLog('SSH Keypair:', sshKeyPair);

        console.log('Reading instance from provider.');
        setLog('Reading instances from provider.');
        const droplets = await client.getDropletsByTag(DropletBaseName);

        let droplet;
        if (droplets.length > 0) {
            droplet = droplets.find(d => d.region.slug === region);
        }

        if (!droplet) {
            console.log(`Instance not available in ${region} region, creating.`);
            setLog(`Instance not available in ${region} region, creating.`);
            let userData = CloudInitUserData(sshKeyPair.authorizedKey, token);
            console.log('generated user data: ', userData);
            setLog('generated user data: ', userData);
            droplet = await client.createDroplet(sshKeys, name, region, DropletSize, userData, DropletImage, [
                DropletBaseName,
            ]);

            console.log('Creating firewall for the instance.');
            setLog('Creating firewall for the instance.');
            await addFirewallToDroplet(DropletBaseName, droplet.id);
        }

        // Save SSH by droplet key (used to ssh terminal connect)
        console.log('Saving SSH by droplet key.');
        setLog('Saving SSH by droplet key.');
        AsyncStorage.setItem('DROPLET_SSH_KEY_PAIR' + droplet.id, JSON.stringify(sshKeyPair));

        console.log('Waiting for the instance IP address.');
        setLog('Waiting for the instance IP address.');
        let ipAddress = await getIpAddress(droplet);
        console.log('IP address to be used for VPN:', ipAddress);
        setLog('IP address to be used for VPN:', ipAddress);

        console.log('Starting SSH connection to the instance on port 2222.');
        setLog('Starting SSH connection to the instance on port 2222.');
        let sshClient = new SSHClient(sshKeyPair, 'core', ipAddress, 2222);

        await waitForSSHConnection(sshClient);

        await waitForVPNService(sshClient);

        console.log('Reading authentication data from VPN service.');
        setLog('Reading authentication data from VPN service.');

        let [domain, password] = await Promise.all([
            sshClient.run('/usr/bin/cat /home/core/domain'),
            sshClient.run('docker exec strongswan /bin/sh -c "cat /etc/ipsec.d/client.password"'),
        ]);

        domain = domain.replace(/[\n\r]+/g, '');
        password = password.replace(/[\n\r]+/g, '');

        console.log('Closing SSH connection.');
        setLog('Closing SSH connection.');
        sshClient.closeSession();
        sshClient = null;

        return {
            server: {
                provider: 'digitalocean',
                uid: droplet.id,
                name: droplet.name,
                region: {
                    name: droplet.region.name,
                    slug: droplet.region.slug,
                },
                ipv4_address: ipAddress,
            },
            ipAddress,
            domain,
            password,
        };
    };

    const addFirewallToDroplet = async (droplet_name, dropletId) => {
        const firewallName = droplet_name + '-firewall';

        const firewalls = await client.getAllFirewalls();

        if (firewalls && firewalls.length > 0) {
            const firewall = firewalls.find(f => f.name === firewallName);

            if (firewall) {
                await client.addDropletToFirewall(firewall.id, dropletId);
            }
        } else {
            await client.createFirewall(firewallName, dropletId);
        }
    };

    const waitForVPNService = async sshClient => {
        console.log('Waiting for VPN service to become active.');
        setLog('Waiting for VPN service to become active.');
        let countWaitingForVPN = 10;
        do {
            console.log('Checking VPN service, attempt: ', 10 - countWaitingForVPN);
            setLog('Checking VPN service, attempt: ', 10 - countWaitingForVPN);
            countWaitingForVPN--;
            try {
                await sshClient.run('docker logs strongswan --until=5s &>/dev/null');
                countWaitingForVPN = 0;
            } catch (e) {
                console.warn(`Attempt ${countWaitingForVPN} failed.`, e);
                if (countWaitingForVPN === 0) {
                    throw e;
                }
                await sleep(countWaitingForVPN * 1000);
            }
        } while (countWaitingForVPN > 0);
    };

    const waitForSSHConnection = async sshClient => {
        let trialLeft = 10;
        do {
            console.log('Waiting for SSH, attempt:', 10 - trialLeft);
            setLog('Waiting for SSH, attempt:', 10 - trialLeft);
            trialLeft--;
            try {
                await sshClient.openSession();
                trialLeft = 0;
            } catch (e) {
                console.warn('ssh connection not ready, trial left:', trialLeft);
                await sleep(trialLeft * 1000);
            }
        } while (trialLeft > 0);
    };

    const getIpAddress = async droplet => {
        for (let i = 1; i < 10; i++) {
            for (const ip of droplet.networks.v4) {
                if (ip.ip_address) {
                    return ip.ip_address;
                }
            }

            await sleep(i * 1000);

            droplet = await client.getDropletById(droplet.id);
        }

        throw new Error('Timed out waiting for Droplet provision.');
    };

    return {
        run,
    };
};

export default Deploy;
