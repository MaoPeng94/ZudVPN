'use strict';

import SSHClient from './../../ssh/client';
import AsyncStorage from '@react-native-community/async-storage';
import CloudInitUserData from './cloudinit_userdata';
import { sleep } from '../../helper';
import Keygen from './../../ssh/keygen';
import logger from '../../logger';

const DropletBaseName = 'zudvpn';
const DropletImage = 'coreos-stable';
const DropletSize = 's-1vcpu-1gb';
const AutogeneratedSSHKey = 'zudvpn';

const Deploy = ({ client, token, region, notify }) => {
    const name = `${DropletBaseName}-${region}`;

    const run = async () => {
        notify('progress', 'Starting secure connection');

        let sshKeys = await client.getAccountSSHKeys();
        let sshKeyId = null;
        let sshKeyPair = null;

        for (let i = 0, l = sshKeys.length; i < l; i++) {
            sshKeyId = sshKeys[i];
            sshKeyPair = await AsyncStorage.getItem('SSH_KEY_PAIR' + sshKeyId);
            if (sshKeyPair) {
                sshKeyPair = JSON.parse(sshKeyPair);
                break;
            }
        }

        if (!sshKeyPair) {
            sshKeyPair = await Keygen.generateKeyPair();

            sshKeyId = await client.createSSHKey(AutogeneratedSSHKey, sshKeyPair.authorizedKey);
            sshKeys.push(sshKeyId);

            AsyncStorage.setItem('SSH_KEY_PAIR' + sshKeyId, JSON.stringify(sshKeyPair));
        }

        logger.debug('[DigitalOcean] SSH Keypair:', sshKeyPair);
        const droplets = await client.getDropletsByTag(DropletBaseName);

        let droplet;
        if (droplets.length > 0) {
            droplet = droplets.find(d => d.region.slug === region);
        }

        if (!droplet) {
            notify('progress', 'Creating a server');

            let userData = CloudInitUserData(sshKeyPair.authorizedKey, token);

            logger.debug(['[DigitalOcean] Generated user data: ', userData]);
            droplet = await client.createDroplet(sshKeys, name, region, DropletSize, userData, DropletImage, [
                DropletBaseName,
            ]);

            notify('progress', 'Creating a firewall');
            await addFirewallToDroplet(DropletBaseName, droplet.id);
        }

        // Save SSH by droplet key (used to ssh terminal connect)
        AsyncStorage.setItem('DROPLET_SSH_KEY_PAIR' + droplet.id, JSON.stringify(sshKeyPair));

        notify('progress', 'Waiting for server IP address');
        let ipAddress = await getIpAddress(droplet);
        notify('progress', 'VPN IP address: ' + ipAddress);

        notify('progress', 'Connecting to server');
        let sshClient = new SSHClient(sshKeyPair, 'core', ipAddress, 2222);

        await waitForSSHConnection(sshClient);

        notify('progress', 'Starting up VPN service');
        await waitForVPNService(sshClient);

        logger.info('[DigitalOcean] Reading authentication data from VPN service.');
        notify('progress', 'Reading authentication');
        let [domain, password] = await Promise.all([
            sshClient.run('/usr/bin/cat /home/core/domain'),
            sshClient.run('docker exec strongswan /bin/sh -c "cat /etc/ipsec.d/client.password"'),
        ]);

        domain = domain.replace(/[\n\r]+/g, '');
        password = password.replace(/[\n\r]+/g, '');

        sshClient.closeSession();
        sshClient = null;

        return {
            server: {
                provider: 'digitalocean',
                uid: droplet.id,
                name: droplet.name,
                region: {
                    name: droplet.region.name,
                    slug: droplet.region.slug,
                },
                ipv4_address: ipAddress,
            },
            ipAddress,
            domain,
            username: 'vpn',
            password,
        };
    };

    const addFirewallToDroplet = async (droplet_name, dropletId) => {
        const firewallName = droplet_name + '-firewall';

        const firewalls = await client.getAllFirewalls();

        if (firewalls && firewalls.length > 0) {
            const firewall = firewalls.find(f => f.name === firewallName);

            if (firewall) {
                await client.addDropletToFirewall(firewall.id, dropletId);
            }
        } else {
            await client.createFirewall(firewallName, dropletId);
        }
    };

    const waitForVPNService = async sshClient => {
        let countWaitingForVPN = 10;
        do {
            countWaitingForVPN--;
            try {
                await sshClient.run('docker logs strongswan --until=5s &>/dev/null');
                countWaitingForVPN = 0;
            } catch (e) {
                logger.debug(`Attempt ${10 - countWaitingForVPN}/10 failed, reason: ${e}`);

                if (countWaitingForVPN === 0) {
                    throw e;
                }
                await sleep(countWaitingForVPN * 1000);
            }
        } while (countWaitingForVPN > 0);
    };

    const waitForSSHConnection = async sshClient => {
        let trialLeft = 10;
        do {
            trialLeft--;
            try {
                await sshClient.openSession();
                trialLeft = 0;
            } catch (e) {
                logger.debug(`[DigitalOcean] SSH connection not ready: ${e}, retrying ${10 - trialLeft}/10`);

                await sleep(trialLeft * 1000);
            }
        } while (trialLeft > 0);
    };

    const getIpAddress = async droplet => {
        for (let i = 1; i < 10; i++) {
            for (const ip of droplet.networks.v4) {
                if (ip.ip_address) {
                    return ip.ip_address;
                }
            }

            await sleep(i * 1000);

            droplet = await client.getDropletById(droplet.id);
        }

        throw new Error('Timed out waiting for server provisioning.');
    };

    return {
        run,
    };
};

export default Deploy;
